1. Iterative - Inorder, PreOrder and Postorder
  - Use stack to mimic recursion 
  - Inorder 
      --> Push root to stack, change root to root->left, if root is null, pop the top element and print, change root to top->right
  - Preorder 
      --> Pop from stack and print. If top->right is not null, add it to stack, If top->left is not null, add it to stack
  - Postorder
      --> Use two stacks or below method
      --> The same logic for PreOrder with a little modification i.e. Add Left Child Before Right Child will give the order which is reverse of expected postorder.  Reverse this to get the expected solution. 
  
2.  Zig Zag Level Order Traversal Bt 
  - Use the same logic for as for Level order traversal. Just swap the output for alternating rows.

3.  Vertical Order traversal of Binary Tree
  - Do level order, root will have horizontal distance = 0, for left child hd = parent.hd - 1 and for right child hd = parent.hd + 1
  - Store this in a map with hd as key.
  
4.  Path Sum, Root to Leaf Paths With Sum
  - if root is null return , else if leaf node check for sum, if sum matches add it to result
  - left || right
  
5.  Max Depth Of Binary Tree
  - if root is null return 0
  - 1 + max(leftDepth, rightDepth)
  
6.  Min Depth Of Binary Tree 
  -
  - Can use BFS

7.  Balanced Binary Tree
  - Use recursive approach, check depth of left subtree, right subtree for each node, if difference between them is > 1, it's not balanced 
  - Better approach O(N) - Refer
    - https://leetcode.com/problems/balanced-binary-tree/discuss/35691/The-bottom-up-O(N)-solution-would-be-better
    - https://www.youtube.com/watch?v=nOcFiGl5Vy4
  
